\chapter{Предложенный алгоритм для подсчета экспоненты}

\section{Сокращение области}

Для сокращения области был использован подход, упомянутый еще в книге Харта\cite{hart} в 1978.
Вариации данного подхода были и использованы в реализации функции подсчета экспоненты и в glibc, и в libclc.
Данный подход основан использовании способа представления чисел с плавающей точкой.
Для чисел с плавающей точкой легко реализуема функция возведения в целочисленную степень основания системы счисления, в нашем случае -- 2.
Для этого достаточно записать значение степени (в случае IEEE 754 сдвинутое на константу смещения) в поле числа, предназначенное для экспоненты.

Учитывая выше сказанное используют следующий подход.
Аргумет функции \textit{arg} представляют в следующем виде:

\begin{equation}
    arg = k \cdot \ln{2} + r
    \label{eq:exp:reduce}
\end{equation}

где:

\begin{itemize}
    \item[] k -- целое число;
    \item[] $r \in [-\frac{\ln{2}}{2}, \frac{\ln{2}}{2}] \approx [-0.34658, 0.34658]$
\end{itemize}

Соответственно, для восстановления результата получаем:

\begin{equation}
    exp(arg) = e^{arg} = e^{k \cdot \ln{2} + r} = e^{r} \cdot e^{k \cdot \ln{2}} = e^{r} \cdot (e^{\ln{2}})^{k} = e^{r} \cdot 2^{k}
    \label{eq:exp:reconstr}
\end{equation}

Выражение $2^{k}$ легко вычислимо, остается вычислить $e^{r}$ на отрезке $[-\frac{\ln{2}}{2}, \frac{\ln{2}}{2}]$.
Таким образом, область сокращена со всей области, представимой числами с плавающей точкой, до отрезка $[-\frac{\ln{2}}{2}, \frac{\ln{2}}{2}]$ (использование отрезка вместо интервала здесь довольно условно, так как значение $\frac{\ln{2}}{2}$ в любом случае не представимо точно числом с плавающей точкой любой точности).

\subsection{Возможные переполнения и дополнительное ограничение аргумента}

Экспонента является быстро растущей функцией, она растет быстрее функции $f(x) = x$.
Соответственно, существует некий порог на входной аргумент $arg_{of}$, при превышении которого произойдет переполнение результата функции сверху.

Данный порог можно оценить используя формулу~\ref{eq:exp:reconstr}.
Значение \textit{k} должно быть записано в поле экспоненты числа с плавающей точкой, соответственно оно не должно превышать максимального возможного значения.
Для чисел двойной точности данное значение равно $e_{max} = 1023$.
Соответственно, порог равен: $arg_{uf} \approx 1023 \cdot \ln{2} \approx 709.1$

При $x \to -\infty$ экспонента быстро стремиться к нулю, что означает, что существует некий отрицательный порог на входной аргумент $arg_{uf}$, при превышении которого произойдет переполнение результата функции снизу.
Данный порог также можно оценить, использую формулу~\ref{eq:exp:reconstr}.
Минимальное значение экспоненты в нормализованном представлении числа $e_{min} = -1022$.
Данное значение сохраняется и для денормализованных чисел.
Однако само представление денормализованных чисел позволяет записывать степени двойки меньшие, чем -1022.
Максимальная возможная степень увеличивается на битность представления дроби, для чисел двойной точности 52.
То есть, минимальное возможное значение $k$ это $-1022 - 52 = -1074$.
Соответственно, примерное значение порога для переполнения снизу: $arg_{uf} \approx -1074 \cdot \ln{2} \approx -744.5$

Таким образом, для всех входных аргументов, больших $arg_{of}$ (в том числе $+\infty$), результат функции равен $+\infty$, а для все входных аргументов, меньших $arg_{uf}$ (в том числе $-\infty$), результат функции равен +0.0.
Ввиду данного факта возможно ограничить входной аргумент некоторым отрезком, охватывающим отрезок $[arg_{uf}, arg_{of}] \approx [-744.5, 709.1]$, так что результат функции не изменится.
Ограничить отрезком здесь означает, что если число выходит за границы отрезка, оно приравнивается ближайшей границе.

Данное дополнительное ограничение позволяет упростить вычисление \textit{k}, объединить несколько краевых случаев -- $\pm \infty$, переполнение сверху и снизу -- в один, что будет рассмотрено в дальнейшем.
Данное дополнительное ограничение можно эффективно (2 vISA инструкции) реализовать с помощью функции \textbf{clamp}:

\begin{lstlisting}
arg = clamp(arg, -800.0, 800.0);
\end{lstlisting}

Обоснование выбора отрезка [-800, 800] будет дано при рассмотрении вопроса восстановления значения функции на всей области.

\subsection{Вычисление параметра k}

Исходя из формулы~\ref{eq:exp:reduce}, можно получить, что \textit{k} равно:

\begin{equation}
    k = [\frac{1}{\ln{2}} \cdot arg]
\end{equation}

где $[*]$ означает округление до ближайшего целого.

Если $arg \in [-800, 800]$, то $k \in [-\frac{800}{\ln{2}}, \frac{800}{\ln{2}}] \approx [-1154.2, 1154.2]$.
Сумма числа из данного интервала с числом 0.5 или -0.5 точно представима в числах двойной точности.
Что позволяет использовать приведение числа с плавающей точкой к целому для получения значения $k$.
Приведение к целому использует отбрасывание дробной части, что не эквивалентно округлению до ближайшего целого.
Перейти к округлению до ближайшего можно по формуле:

\begin{equation}
    [x] = \lfloor x + \frac{1}{2} \cdot sgn(x) \rfloor
\end{equation}

где $\lfloor * \rfloor$ означает отбрасывание дробной части (округление вниз для положительных чисел, вверх -- для отрицательных), $sgn(*)$ -- сигнум функция: возвращает -1 для отрицательных чисел, 1 -- для положительных, 0 -- для нуля.

В рамках векторной арифметики данное преобразование можно представить добавлением вектора из констант $\pm 0.5$, от краевого случая с нулём можно отказаться и возвращать +0.5 в случае неотрицательных чисел.
Сформировать такой вектор можно за одну инструкцию \textbf{SEL} (select), что соответствует методу \textbf{merge} в языке CM.

Для реализации такого подхода округления была написана вспомогательная функция \textbf{round\_fast}:

\begin{lstlisting}[language=C++]
template<typename IntT, typename FloatT, int width>
vector<IntT, width> round_fast(vector<FloatT, width> arg) {
    detail_round_fast::arg_type_check<FloatT, IntT>();
  Mask<width> is_negative(arg < 0.0);
  vector<FloatT, width> delta = 0.5;
  vector<FloatT, width> delta_for_neg = -0.5;
  delta.merge(delta_for_neg, is_negative.get());
  return arg + delta;
}
\end{lstlisting}

Стоит отметить, что данную функцию возможно использовать вне алгоритма экспоненты для выполнения округления до целых.
Однако существуют полуинтервалы входных значений -- $(-2^{24}, -2^{23}] \cup [2^{23}, 2^{24})$ для чисел одинарной точности и $(-2^{53}, -2^{52}] \cup [2^{52}, 2^{53})$ для чисел двойной точности -- на которых функция способна возвращать неверный результат (отличающийся на $\pm1$) в зависимости от режима округления.

\subsection{Вычисление параметра r}

Исходя из формулы~\ref{eq:exp:reduce}, зная \textit{k}, можно получить \textit{r} по формуле:

\begin{equation}
    r = arg - k \cdot \ln{2}
\end{equation}

Такое вычисление можно произвести за одну \foreignlanguage{english}{fused multiply-add} инструкцию.
Однако при таком наивном подходе в тех случаях, когда значение $arg$ близко к значению $k \cdot \ln{2}$, ошибка полученного значения \textit{r} будет велика, что приведет к значительной ошибке при подсчете $e^{r}$ и соответственно значительной ошибке итогового результата.

Эффективный способ обойти данную проблему был предложен Коди и Вейтом в 1980\cite{cody-waite}.
Данный подход называют методом Коди и Вейта.
Он заключается в разделении константы $\ln{2}$ на две части:

\begin{itemize}
    \item $\ln{2}_{hi}$ --- старшая часть: старшие биты числа $\ln{2}$, достаточное количество младших битов должны быть равны 0 для того, чтобы произведение $k \cdot \ln{2}_{hi}$ было всегда точно представимо в виде числа с плавающей точкой необходимой точности;
    \item $\ln{2}_{lo}$ --- младшая часть: младшие биты числа $\ln{2}$.
\end{itemize}

Сумма $\ln{2}_{hi} + \ln{2}_{lo}$ равна правильно округленному значению $\ln{2}$, однако совместно $\ln{2}_{hi}$ и $\ln{2}_{lo}$ представляют значение $\ln{2}$ эффективно с большей точностью, чем точность типа, которым представлено каждое число в отдельности.

Используя данные константы, можно посчитать \textit{r} гораздо точнее по следующей формуле:

\begin{equation}
    r = (arg - k \cdot ln{2}_{hi}) - k \cdot ln{2}_{lo}
\end{equation}

Порядок вычислений здесь исключительно важен.
Данные вычисления возможно выполнить за две инструкции \foreignlanguage{english}{fused multiply-add}.

В рамках данной работы для чисел двойной точности были выбраны следующие константы:

\begin{lstlisting}[caption={Константы $\ln{2}_{hi}$ и $\ln{2}_{lo}$}, captionpos=b, label={lst:ln2_hi_lo}]
constexpr double ln2_hi = 0x0.b17217f7d1p0;
constexpr double ln2_lo = 0x0.0000000000cf79abc9e3b398p0;
\end{lstlisting}

\section{Полиномиальное приближение}

В рамках данной работы было рассмотрено два способа приближения $e^r$, \newline $r \in [-\frac{\ln{2}}{2}, \frac{\ln{2}}{2}]$ полиномом:

\begin{itemize}
    \item подход glibc с приближением функции $r \cdot \frac{e^{r} + 1}{e^{r} - 1}$ полиномом 5-ой степени от $r^2$, c дальнейшим восстановлением значения $e^r$;
    \item приближение $e^r$ напрямую полиномом 11-ой степени от \textit{r}.
\end{itemize}

\subsection{Подход glibc}
\label{sec:work:exp:glibc}

Подход glibc заключается в приближении не самой функции $e^r$, а сложной функции:

\begin{equation}
    f(r) = r \cdot \frac{e^{r} + 1}{e^{r} - 1}
\end{equation}

Данная функция обладает преимуществом по сравнению с оригинальной функцией $e^r$.
В отличие от $e^r$, $f(r)$ -- четна, что означает, что аппроксимирующий ее полином будет состоять только из четных степеней.
Что в свою очередь означает большую скорость сходимости при замене переменной $g(r) = r^2$.
Так чтобы ошибка приближения функции $f(g)$ была меньше 1 ULP, достаточно полинома всего пятой степени.
Однако за высокую скорость сходимости при таком подходе приходится платить необходимостью восстанавливать значение $e^{r_0}$ из подсчитанного $f(r_0)$.

Для того, чтобы восстановить $e^r$ без потерь в точности, $f(r)$ представляется в виде:

\begin{equation}
    f(r) = r \cdot \frac{e^{r} + 1}{e^{r} - 1} = 2 + \frac{r^2}{6} \cdot R(r^2)
\end{equation}

Из данного выражения можно вывести $R(g)$:

\begin{equation}
    R(g) = R(r^2) = \frac{6}{r} \left( \frac{e^{r} + 1}{e^{r} - 1} - \frac{2}{r} \right) = \frac{6}{\sqrt{g}} \left( \frac{e^{\sqrt{g}} + 1}{e^{\sqrt{g}} - 1} - \frac{2}{\sqrt{g}} \right)
\end{equation}

И уже функция $R(g)$ приближается полиномом 5-ой степени $P_5(g)$.
Тогда значение $e^r$ можно выразить следующим образом:

\begin{multline}
    e^r = 1 + r + \frac{r^2}{2} + \frac{r^3}{2} \cdot \frac{3 - (R(r^2) + \frac{r}{2} \cdot R(r^2))}{6 - r \cdot (3 - \frac{r}{2} \cdot R(r^2))} \approx \\
    \approx 1 + r + \frac{r^2}{2} + \frac{r^3}{2} \cdot \frac{3 - (P_5(r^2) + \frac{r}{2} \cdot P_5(r^2))}{6 - r \cdot (3 - \frac{r}{2} \cdot P_5(r^2))}
\end{multline}

Данное выражение, хоть оно и содержит много повторяющихся подвыражений, требует большого количества дополнительных вычислений, среди которых есть операция деления, которая является очень дорогой в архитектуре \foreignlanguage{english}{Intel Processor Graphics}.

\subsection{Прямое приближение $e^r$}

На отрезке $[-\frac{\ln{2}}{2}, \frac{\ln{2}}{2}]$ функция $e^r$ монотонно возрастает и принимает значения $e^r \in [e^{-\frac{\ln{2}}{2}}, e^{\frac{\ln{2}}{2}}] = [\frac{\sqrt{2}}{2}, \sqrt{2}] \subset (\frac{1}{2}, 2)$.
На интервале $(\frac{1}{2}, 2)$ функция $ULP(x)$ принимает всего два значения $2^{-53}$ и $2^{-52}$.
Так как значение ULP варьируется не значительно, можно применить алгоритм Ремеза и найти аппроксимирующий полином.

Путем подбора было установлено, что для приближения с абсолютной ошибкой, меньшей $2^{-53}$, то есть с ошибкой меньшей 1 ULP, на исследуемом отрезке достаточно полинома 11-ой степени.

Найденные значения коэффициентов:

\begin{align*}
a_{0} &= 1.0\\
a_{1} &= 1.0\\
a_{2} &= 5.000000000000018389e-01\\
a_{3} &= 1.666666666666672403e-01\\
a_{4} &= 4.166666666648806972e-02\\
a_{5} &= 8.333333333299448800e-03\\
a_{6} &= 1.388888895232078842e-03\\
a_{7} &= 1.984126992839627458e-04\\
a_{8} &= 2.480148547660227862e-05\\
a_{9} &= 2.755720899040766077e-06\\
a_{10} &= 2.763264154737745042e-07\\
a_{11} &= 2.511970386342627276e-08
\end{align*}

\section{Восстановление значения на всей области}

Приведем более кратко формулу восстановления значения на всей области (формулу~\ref{eq:exp:reconstr}):

\begin{equation}
    e^{arg}  = e^{r} \cdot 2^{k}
    \label{eq:exp:reconstr}
\end{equation}

Соответственно, для восстановления значения функции необходимо вычислить $2^k$.
В зависимости от значения \textit{k} возможны 4 случая:

\begin{itemize}
    \item $k < e_{min} - (p - 1) = -1022 - 52 = -1074$:
    
    происходит переполнение снизу, функция должна вернуть 0;
    \item $-1074 = e_{min} - (p - 1) \leq k < e_{min} = -1022$:
    
    $2^k$ представимо в виде денормализованного числа;
    \item $-1022 = e_{min} \leq k \leq e_{max} = 1023$:
    
    $2^k$ представимо в виде нормализованного числа;
    \item $k > e_{max} = 1023$:
    
    происходит переполнение сверху, функция должна вернуть $+\infty$.
\end{itemize}

В скалярных реализация возможно рассмотреть каждые из указанных выше случаев отдельно (так, например, реализован этап восстановления значения в функции exp в библиотеке glibc).
Однако в случае с векторным кодом, как уже говорилось ранее, использование ветвлений не оптимально при произвольных входных данных.
Поэтому был предложен следующий алгоритм:

\begin{enumerate}
    \item \textit{arg} изначально ограничивается так, что \textit{k} не может по модулю более чем в два раза превосходить $max(|e_{min}|, |e_{max}|) = 1023$.
    Соответственно, было выбрано ограничение отрезком $[-800, 800]$, которому соответствует $k \in [-1154, 1154] \subset (-\frac{800}{\ln{2}}, \frac{800}{\ln{2}})$.
    \item \textit{k} разбивается на две составляющие $k_1 = \lfloor \frac{k}{2} \rfloor$ и $k_2 = k - k_1$.
    Таким образом и $k_1$, и $k_2$ гарантированно принадлежат отрезку $[e_{min}, e_{max}]$.
    \item Вычисляются $2^{k_1}$ и $2^{k_2}$
    \item Восстанавливается результат по формуле $e^{arg} = (e^r \cdot 2^{k_1}) \cdot 2^{k_2}$. Порядок перемножения здесь важен, так как на грани переполнения, когда $k = e_{max} + 1$, возможны такие значения $e^r$ с экспонентой равной -1, что итоговая экспонента числа $e^{arg}$ будет равна валидному значению $e_{max}$, а при перемножении $2^{k_1} \cdot 2^{k_2}$ в таком случае получится бесконечность, которая в итоге приведет к тому, что результат всей функции будет равен бесконечности, что неверно.
\end{enumerate}

Для возведения 2 в степень $k_i$ было предложено использовать бинарный сдвиг смещенного значения экспоненты: $(k_i + bias) << 52$.
Данный способ быстрее, чем применение вспомогательной функции \textbf{set\_exp} к единице, так как он не требует дополнительно создания константы единицы.

При указанном подходе в одном линейном коде учитываются краевые случаи с переполнением сверху, снизу и $\pm \infty$ как аргумент.
Единственный неучтенный краевой случай -- это NaN.
Он реализуется через дополнительную проверку, которую пользователь может убрать из кода с помощью тэга в том случае, если он гарантирует, что NaN на вход функции подан не будет.