
\chapter{Общие подходы к проектированию векторных функций}

\section{Интерфейс}

В качестве примера интерфейсов математических функций в данной работе была рассмотрена математическая библиотека языка C++\cite{c++11}.
Данная библиотека основана на стандартной математической библиотеке языка C, описанной в стандарте C99\cite{c99}, однако некоторые интерфейсы были переделаны с учетом возможностей C++ (так например std::isnan в C++ является перегруженной функцией, когда isnan в C -- это макрос).
Данные возможности я зыка C++ -- перегрузка, шаблоны -- доступны в языке CM, что делает интерфейсы математической библиотеки языка C++ более предпочтительными по сравнению с математичкой библиотекой языка C.

\section{Краевые случаи}

Существуют такие наборы входных данных, результат функции из математической библиотеки над которыми нельзя определить исходя из чисто математических свойств вычисляемой трансцендентной функции.
Такие наборы данных называются краевыми случаями.
Для краевых случаев описание математической библиотеки должно определять возвращаемые значения.
Так как примером интерфейса была выбрана стандартная математическая библиотека языка C++, краевые случаи также были взяты из стандарта языка C++\cite{c++11}.
Описание краевых случаев унаследовано из стандарта C99\cite{c99}.

Следует отметить, что описание математической библиотеки языка OpenCL\cite{opencl11} также ссылается на стандарт C99 для определения краевых случаев:

\begin{displayquote}
The edge case behavior of the math functions (section 6.11.2) shall conform to sections F.9 and
G.6 of ISO/IEC 9899:TC 2 (commonly known as C99, TC2), except where noted below in
section 7.5.1.
\end{displayquote}

В секции 7.5.1 указаны некоторые послабления для возможных реализаций функций.
Например, разрешатся возвращать не сигнальный NaN в тех случаях, в которых стандарт C99 требует возвращения сигнального.

\subsection{Экспонента}

Стандарт C99\cite{c99} определяет следующие краевые случаи для функции подсчета экспоненты:

\begin{itemize}
    \item В случае аргумента равного $\pm 0$ возвращается 1;
    \item В случае аргумента равного $-\infty$ возвращается +0;
    \item В случае аргумента равного $+\infty$ возвращается $+\infty$;
    \item В случае аргумента равного NaN возвращается NaN;
    \item В случае переполнения снизу возвращается правильно округленный результат, то есть +0;
    \item В случае переполнения сверху возвращается +HUGE\_VAL, +HUGE\_VALF для перегрузок для чисел двойной и одинарной точности соответственно.
\end{itemize}

Согласно пункту F.9/2 стандарта C99 для архитектур, в которых реализация чисел с плавающей точкой соответствует стандарту IEEE 754, +HUGE\_VAL и +HUGE\_VALF равны положительным бесконечностям для чисел двойной и одинарной точности соответственно.

\subsection{Логарифм}

Стандарт C99\cite{c99} определяет следующие краевые случаи для функции подсчета логарифма:

\begin{itemize}
    \item В случае аргумента равного $\pm 0$ возвращается $-\infty$;
    \item В случае аргумента равного 1 возвращается +0;
    \item В случае аргумента равного $+\infty$ возвращается $+\infty$;
    \item В случае аргумента равного NaN возвращается NaN;
    \item В случае отрицательного аргумента (в том числе $-\infty$) возвращается NaN.
\end{itemize}

\section{Поток исполнения}

Одним из общих подходов при построении векторных функций было выбрано минимизация ветвлений.
Это обусловлено тем, что при \textbf{SIMD} потоке управления с высокой вероятностью исполняются обе ветки ветвления.
Что делает более выгодным алгоритм, в котором требуется совершить действий больше, чем в одной ветке, но в нем отсутствует ветвление.
Конечно, существуют тесты, в которых будет более производителен обратный подход -- тесты с однотипными данными, всегда проходящие по одной и той же ветке исполнения, однако в данной работе рассматривается случай оптимизации алгоритмов для максимально разнообразных данных.

Выше указанный подход исключает такой распространенный прием оптимизации скалярных функций, как рассмотрение некоторых частных случаев и ранний выход.
Так, например, часто применяется проверка аргумента на близость к нулю и применения для этого конкретного случая ряда Тейлора малой степени.
Данная скалярная оптимизация не применима для векторных вычислений: случаи, в которых она сработает и даст ускорение, редки, а для самого распространенного хода исполнения добавится лишняя проверка, что только замедлит исполнение.

