
%--------------------------------------%
\chapter{Анализ существующих реализаций}
%--------------------------------------%

В рамках данной работы особый интерес представляют реализации векторных математических библиотек.
Однако найти открытые реализации подобных библиотек проблематично. 
В частности это связано с тем, что большинство популярных, часто используемых для написания библиотек, компилируемых языков не поддерживают явные векторные типы.
Тем не менее существуют проприетарные векторные математические библиотеки.

Так компания AMD предоставляет библиотеку LibM, в рамках которой в частности реализованы векторные экспонента и логарифм\cite[с.~189, 195]{amd-math}.
Максимальный размер вектора в данной библиотеке всего 2 для чисел двойной точности (есть версии функции с размером 4, но они просто принимают два вектора по 2 элемента и исполняются чуть меньше чем в 2 раза дольше). 
Что значительно меньше чем в архитектуре \foreignlanguage{english}{Intel Processor Graphics} --- максимально 8 для чипа 9-ого поколения.
Из-за чего данный пример являлся бы слабым даже в случае открытого исходного кода.

Сама компания Intel также предоставляет векторную математическую библиотеку \textbf{SVML}(\foreignlanguage{english}{\textbf{S}hort \textbf{V}ector \textbf{M}ath \textbf{L}ibrary}) в виде встроенных функций в компилятор Intel C++.
Максимальный размер вектора в данной библиотеке равен 8, что соответствует возможностям рассматриваемой архитектуры, но кода библиотеки SVML нет в открытом доступе, что, очевидно, делает невозможным ее анализ.

В качестве примера открытой реализации векторной математической библиотеки в данной работе была рассмотрена библиотека libclc --- стандартная библиотека языка OpenCL, реализованная в рамках проекта LLVM.
Код данной библиотеки скалярный, в нем не использованы векторные типы, однако учитывая специфику архитектур и компиляторов, для которых которых данный код разрабатывался, можно предположить, что его оптимизация происходила с учетом дальнейшей векторизации кода.
В качестве примера скалярной математической библиотеки была рассмотрена реализация математической библиотеки языка C --- libm --- в рамках GNU C Library (glibc).

\section{Библиотека libclc}

Общей чертой кода реализации экспоненты и логарифма в библиотеке libclc является отказ от if-конструкций для реализации ветвления в программе.
Вместо этого применяется тернарный оператор, значения для операндов которого последовательно посчитаны в линейном коде.
Что в случае векторного кода не является менее производительным, так как если в векторе присутствую и элементы удовлетворяющие условию, и --- не удовлетворяющие, в любом случае придется вычислить обе ветки.

\subsection{Экспонента}

Реализация экспоненты в библиотек libclc использует таблицу значений и полиномиальное приближение.
Благодаря таблице из 128 значений аппроксимируемая область сокращена до $[-\frac{\ln{2}}{32}, \frac{\ln{2}}{32}]$, что позволило применить на ней многочлен Тейлора 5-ого порядка.
Значение многочлена получено схемой Хорнера.
Использование таблиц делает невозможным применение данного подхода в математической библиотеке языка CM.

Для реализации функции экспоненты вблизи нуля --- expm1 --- применяется та же таблица, что и для обычной экспоненты.

\subsection{Логарифм}

Натуральный логарифм в библиотеке libclc получается из логарифма двоичного по формуле:

\begin{equation}
    \ln{x} = \frac{\log_{2}{x}}{\log_{2}{e}}
\end{equation}

Что является не самым лучшим решением с точки зрения точности результата, так как итоговая относительная ошибка сложится из ошибки представления константы $\log_{2}{e}$ и ошибки подсчета $\log_{2}{x}$.
Однако разработчики библиотеки предпочли этот вариант даже учитывая то, что в исходниках есть отдельно реализованный натуральный логарифм.

Как и в случае с экспонентой, алгоритм использует полиномиальное приближение совместно с таблицей значений, что делает невозможным применение данного алгоритма в рамках математической библиотеки языка CM.

Для реализации функции логарифма вблизи единицы --- log1p --- применяется та же таблица, что и для обычного логарифма.

\section{Библиотека glibc}

В отличие от библиотеки libclc, в библиотеке glibc широко применяются условные конструкции.
Также используется подход с ранним выходом из функции.
Так, например, для экспоненты заранее происходит проверка на переполнение снизу и возвращается ноль в случае положительного результата.
Подобное средство оптимизации не работает для векторных вычислений, так как вероятность того, что переполнение снизу или любой другой краевой случай проявятся для каждого элемента вектора мала.

\subsection{Экспонента}

В алгоритме подсчета экспоненты из библиотеки glibc как и в библиотеке libclc применяется таблица совместно с полиномиальным приближением.
Таблица в подходе glibc в два раза больше, из-за чего и рассматриваемая область сокращена в два раза по сравнению с реализацией libclc --- $[-\frac{\ln{2}}{64}, \frac{\ln{2}}{64}]$.
Как и в реализации из библиотеки libclc, в glibc применяется полином 5-ой степени.

Функция подсчета значения экспоненты вблизи нуля expm1 в отличие от реализации просто экспоненты не использует таблицу заранее подсчитанных значений.
Алгоритм данной функции основан только на полиномиальном приближении.

В данном алгоритме аппроксимируется не сама функция $e^{x} - 1$, а сложная функция $F(e^{x}-1)$:

\begin{equation}
    f(x) = F(e^{x}-1) = x \cdot \frac{e^{x}+1}{e^{x}-1}
\end{equation}

Функция $f(x)$ приближается полиномом 6-ой степени от аргумента $x^{2}$ -- $P_{6}(x^{2})$.
После чего значение $e^{x}-1$ получается применением обратной функции $F^{-1}$.

Данный подход возможно применить для подсчета экспоненты в рамках библиотеки языка CM.
Он будет более подробно рассмотрен в пункте~\ref{sec:work:exp:glibc}.

\subsection{Логарифм}

Аналогично экспоненте основная функция подсчета логарифма использует таблицу (512 значений) и дальнейшее приближение полиномом, функция подсчета логарифма вблизи единицы logp1 основывается только на полиномиальном приближении.
Для аппроксимации функции $\ln{(1 + x)}$ используется замена переменной:

\begin{align}
    z(x) = \frac{x}{2+x} \\
    x(z) = \frac{2z}{1-z}
\end{align}

Функция новой переменной получается нечетной для приближения используется полином 7-ой степени от $z^{2}$: $P_{7}(z^{2})$:

\begin{equation}
    f(z) = \ln{(1 + x(z))} \approx z P_{7}(z^{2})
\end{equation}

Данный подход возможно применить для подсчета логарифма в рамках библиотеки языка CM.
Аналогичный подход будет более подробно рассмотрен в пункте~\ref{sec:work:log:approx}.
