

\chapter{Вспомогательные функции и структуры данных}

Для реализации функций подсчета экспоненты и логарифма требуются некоторые другие функции стандартной библиотеки.
На момент написания работы данные функции реализованы не были.
Так что данные функции были реализованы в рамках данной дипломной работы.

\section{Функции манипуляции представления чисел с плавающей точкой}

При построении функций, работающих с числами с плавающей точкой, требуется отдельно работать с полями числа: извлечь экспоненту числа, записать экспоненту, извлечь дробь числа, записать дробь числа.
Для данных операций в рамках данной работы были реализованы следующие вспомогательные функции:

\begin{itemize}
    \item \textbf{get\_biased\_exp} --- извлечь из вектора чисел с плавающей точкой вектор их экспонент в том виде, в котором они закодированы (положительные целые числа, полученные за счёт смещения экспоненты на константу);
    \item \textbf{get\_exp} --- извлечь из вектора чисел с плавающей точкой вектор их экспонент (знаковые целые числа);
    \item \textbf{get\_frac} --- извлечь из вектора чисел с плавающей точкой вектор их дробей в том виде, в котором они закодированы (положительные целые числа);
    \item \textbf{set\_exp} --- записать в вектор чисел с плавающей точкой новые значения экспонент, значения экспонент передаются со знаком, без смещения.
\end{itemize}

Данные функции не являются публичным интерфейсом библиотеки.
Данные функции используются при реализации других функций библиотеки, пользователю не разрешено использовать их напрямую.

Для получения доступа к отдельным битам числа в vISA есть две инструкции:

\begin{itemize}
    \item \textbf{BFE} --- извлекает последовательность из $n$ битов с некоторым смещением $m$ бит из входного операнда и записывает в выходной, $n$ и $m$ также задаются векторными операндами;
    \item \textbf{BFI} --- записывает младшие $n$ бит одного входного операнда в значение другого входного операнда со смещением $m$ бит, результат идет в выходной операнд (входные операнды в vISA не модифицируются), $n$ и $m$ также задаются векторными операндами.
\end{itemize}

Для доступа к функциональности данных инструкций в CM есть встроенные функции \textbf{cm\_bf\_extract} и \textbf{cm\_bf\_insert}.
Минусом данной инструкции и данных функций является то, что их можно применить только к 32-битным целым числам.
Что делает невозможным реализацию \textbf{get\_frac} с помощью \textbf{cm\_bf\_extract} в случае чисел двойной точности.
Однако в случае с \textbf{get\_frac} это не является потенциальной проблемой производительности, так как поле дробной части расположено в представлении чисел с плавающей точкой со смещением ноль, что позволят получить значение данного поля одним наложением маски -- одной инструкцией AND.

В случае с экспонентой, так как ее поле максимум 11 бит в случае чисел двойной точности, ограничение 32-битным типом можно обойти.
Сделать это позволяет адресация регионами.
Вектор чисел двойной точности представляется, как вектор 32-битных целых в два раза большего размера, из которого читаются только нечетные элементы (нумерация начинается с нуля).
Таким образом, чтобы прочитать экспоненту у вектора из восьми чисел двойной точности, достаточно одной инструкции:

\begin{lstlisting}
bfe (M1, 8) V2(0,0)<1> 0xb:ud 0x14:ud V1(0,1)<2;1,0>
\end{lstlisting}

В данном примере:

\begin{itemize}
    \item 0xb=11 --- размер поля экспоненты для чисел двойной точности;
    \item 0x14=20=52 - 32 --- смещение в старшей части числа до поля экспоненты;
    \item (0,1)<2;1,0> --- регион, состоящий только из нечетных элементов.
\end{itemize}

Для изменения экспоненты в векторе из восьми чисел двойной точности также достаточно всего одной инструкции:

\begin{lstlisting}
bfi (M1, 8) V2(0,1)<2> 0xb:ud 0x14:ud V3(0,0)<1;1,0> V1(0,1)<2;1,0>
\end{lstlisting}

В данном примере все аналогично предыдущему, только по сравнению с предыдущей инструкцией в этой добавился еще один векторный операнд V3, содержащий новые значения экспоненты.

\section{fpclassify, isnan, isinf, isnormal}

При работе с числами с плавающей точкой часто необходимо определять класс данных чисел.
Например, функции frexp придется производить дополнительный набор действий для денормализованных чисел.

Для определения классов чисел с плавающей точкой в математической библиотеке языка C++ используются следующие функции:

\begin{itemize}
    \item \textbf{isnormal} --- проверка на нормализованное число;
    \item \textbf{isinf} --- проверка на то, что число является положительной или отрицательной бесконечностью;
    \item \textbf{isnan} --- проверка на то, что число --- NaN;
    \item \textbf{fpclassify} --- Функция, которая определяет класс числа, класс возвращается в виде кода типа int;
\end{itemize}

В математической библиотеке языка C представлено 5 классов чисел с плавающей точкой, которые соответствуют классам, указанным в секции~\ref{sec::ieee}.
Коды данных классов определяют следующие 5 макрасов:

\begin{itemize}
    \item FP\_NORMAL --- нормализованное число;
    \item FP\_SUBNORMAL --- денормализованное число;
    \item FP\_ZERO --- ноль;
    \item FP\_INFINITE --- бесконечность;
    \item FP\_NAN --- NaN.
\end{itemize}

Соответственно, в рамках данной работы было предложено реализовать аналогичные функции с аналогичным интерфейсом, теми же названиями, только принимающими на вход и возвращающими вектор значений.

В качестве вектора булевых значений используется специальный класс маска --- обертка над 32-битным числом, каждый знак которого хранит одно булево значение.
Приведу объявление шаблонной функции isnan:

\begin{lstlisting}[language=C++]
template<typename FloatT, int width>
mask<width>
isnan(vector<FloatT, width> arg);
\end{lstlisting}

В случае же fpclassify возвращается вектор из элементов типа int:

\begin{lstlisting}[language=C++]
template<typename FloatT, int width>
vector<int, width>
fpclassify(vector<FloatT, width> arg);
\end{lstlisting}

Для определения класса числа с плавающей точкой обратимся к таблице из секции~\ref{sec::ieee}:


\begin{table}[h]
    \centering
    \begin{tabular}{>{\centering}p{0.3\textwidth}||>{\centering}p{0.2\textwidth}|>{\centering}p{0.2\textwidth}|>{\centering\arraybackslash}p{0.2\textwidth}}
        \backslashbox{дробь}{экспонента} & 0x0 & 0xF\ldots F & иначе \\
        \hline\hline
        0x0               & ноль & бесконечность & норм. число равное степени двойки \\
        \hline
        иначе           & денорм. число & NaN & норм. число не равное степени двойки
    \end{tabular}
    \caption{Класс числа с плавающей точкой в зависимости от значения поля дроби и экспоненты}
    \label{tab:ieee_classify}
\end{table}

Таким образом, исходя из таблицы, можно ввести базис из 3-ех функций:

\begin{itemize}
    \item \textbf{is\_zero\_or\_subn} --- проверяет, что число -- ноль или денормализовано, для этого сравнивает смещенную экспоненту числа с нулем;
    \item \textbf{is\_inf\_or\_nan} --- проверяет, что число -- бесконечность или NaN, для этого сравнивает смещенную экспоненту числа с её максимальным значением;
    \item \textbf{is\_zero\_or\_inf\_or\_pow2norm} --- проверяет, что число ноль, бесконечность или нормализованное представление степени двойки, для этого сравнивает дробь с нулем.
\end{itemize}

Используя правила булевой логики, из данных трёх базисных функций можно вывести проверки на все 5 классов чисел с плавающей точкой:

\begin{itemize}
    \item \textbf{iszero} = \textbf{is\_zero\_or\_subn} \& \textbf{is\_zero\_or\_inf\_or\_pow2norm}
    \item \textbf{issubnormal} = \textbf{is\_zero\_or\_subn} \& $\sim$\textbf{is\_zero\_or\_inf\_or\_pow2norm}
    \item \textbf{isinf} = \textbf{is\_inf\_or\_nan} \& \textbf{is\_zero\_or\_inf\_or\_pow2norm}
    \item \textbf{isnan} = \textbf{is\_inf\_or\_nan} \& $\sim$\textbf{is\_zero\_or\_inf\_or\_pow2norm}
    \item \textbf{isnormal} = $\sim$\textbf{is\_zero\_or\_subn} \& $\sim$\textbf{is\_inf\_or\_nan}
\end{itemize}

Хотя такая система и стройна в математическом смысле, реализованные так функции не будут давать наилучшую производительность.
Некоторые из выше указанных функций вообще не реализованы в стандартной библиотеке C++: iszero, issubnormal.
Так проверить число на то, является ли оно нулем, можно простым сравнением на ноль: по стандарту IEEE 754 \cite{ieee754} нули равны вне зависимости от знака.

Проверку на бесконечность можно сделать, сравнив модуль числа с константой положительной бесконечности.
Данный подход является наиболее оптимальным, так как архитектура позволяет встраивать взятие модуля как модификатор на операнд.
Соответственно, проверку вектора из 8-ми элементов на бесконечность можно выполнить за одну инструкцию vISA:

\begin{lstlisting}
cmp.eq (M1, 8) P1 (abs)V1(0,0)<1;1,0> 0x7ff0000000000000:df
\end{lstlisting}

Чтобы определить является ли число NaN было выбрано проверить число на неравенство самому себе, так как NaN не равен ничему, даже самому себе, по стандарту IEEE 754.
Такой подход также является наиболее оптимальным, и для проверки вектора из 8-ми чисел достаточно одной инструкции.

Следует отметить, что сами функции is\_zero\_or\_subn и is\_inf\_or\_nan показывают высокую производительность в случае входных векторов размеров больше восьми.
В при реализации функции is\_zero\_or\_subn указанным выше способом был получен выигрыш производительности равный 5\% на тесте с логарифмом по сравнению с подходом, в котором числа сравнивались минимальным нормализованным числом по модулю на меньшее.
Данный результат обусловлен тем, что значение экспоненты умещается в целочисленном типе размером 16 бит.
Одна инструкция способна обработать в 4 раза больше значений данного типа, чем типа чисел двойной точности.
Соответственно, извлечь экспоненту $n$ раз и произвести сравнение $\frac{n}{4}$ раз быстрее чем $n$ сравнений чисел с плавающей точкой.
Следует отметить, что данный результат также обусловлен тем, что инструкция извлечения битового поля из целого 32-битного числа исполняется быстрее, чем сравнение 64-битных чисел с плавающей точкой.

Таким образом единственная функция реализованная через базисные функции -- это isnormal.

Для реализации fpclassify был предложен следующий метод.
Так как конкретными значениями кодов классов чисел возможно манипулировать, было предложено трактовать результат функции is\_zero\_or\_subn как первый бит кода, а результат функции is\_zero\_or\_inf\_or\_pow2norm -- как второй.

\begin{equation}
    res = (is\_zero\_or\_subn << 1) + is\_zero\_or\_inf\_or\_pow2norm
\end{equation}

При таком подходе правильно определяются классы всех чисел кроме нормализованных:

\begin{table}[h]
    \centering
    \begin{tabular}{r|c|c|c|c}
        класс & is\_zero\_or\_subn & is\_zero\_or\_inf\_or\_pow2norm & res & код\\
        \hline
        fp\_nan       & 0 & 0 & 0 & 0 \\
        fp\_infinite  & 0 & 1 & 1 & 1 \\
        fp\_subnormal & 1 & 0 & 2 & 2 \\
        fp\_zero      & 1 & 1 & 3 & 3 \\
        fp\_normal    & 0 & 0 или 1 & 0 или 1 & 4
    \end{tabular}
\end{table}

Для нормализованных чисел было решено предикативно записать в код четверку.

В отличие от математической библиотеки языка C++, в библиотеке языка CM коды классов заданы не в виде макросов, а в виде перечисления с значениями указанными выше:

\begin{lstlisting}
enum {
  fp_nan,
  fp_infinite,
  fp_subnormal,
  fp_zero,
  fp_normal
};
\end{lstlisting}

\section{Тэги-подсказки класса числа с плавающей точкой}

Так как число с плавающей точкой может принимать особые значения, для многих функций математической библиотеки определены краевые случаи -- что функция должна возвращать при некоторых определенных значениях входного аргумента.
В некоторых случая краевые условия задаются классами чисел с плавающей точкой.
Например exp, log, frexp должны возвращать NaN в случае если рагумент тоже NaN.
Для скалярного кода такие условия не являются критичными для производительности, и даже наоборот позволяют оптимизировать код и применять подход с ранним выходом из функции.
В случае векторного кода, как уже говорилось, данный подход не возможен и приходится тратиться на проверки и корректирование элементов вектора в особых случаях.

В связи с этим было предложено расширить интерфейсы некоторых функций по сравнению с аналогами из стандартной библиотеки C++, добавить параметр тэг, который бы позволял пользователю подсказывать функции возможные классы входных аргументов.
В зависимости от значения данного тэга в функции статически (во время компиляции) выбирается наиболее оптимальный алгоритм, отбрасываются ненужные проверки.
Например пользователь может гарантировать, что среди значений входного аргумента не может быть NaN.

Тэг в языке C++ и соответственно в языке CM -- это класс или структура, как правило пустые.
Значение в объекте данного класса имеет только его тип, который и используется в статических анализах и метапрограммировании.
Так в языке C++ есть тэги, отражающие категорию итератора.
Они используются, в частности, для выбора оптимального алгоритма в таких функциях как advance и distance.

В качестве тэга возможных классов числа с плавающей точкой был предложен следующий шаблонный класс:

\begin{lstlisting}
template<unsigned fpclass>
class fpclass_tag :
    public std::integral_constant<unsigned, fpclass> {
// meaningful code
};
\end{lstlisting}

Для удобства использования было сделано несколько базовых тэгов, комбинируя которые можно получить все возможные тэги:

\begin{itemize}
    \item \textbf{fpclass\_tag\_def::nan} --- тэг, указывающий, что число может быть только NaN;
    \item \textbf{fpclass\_tag\_def::infinite} --- тэг, указывающий, что число может быть только одной из двух бесконечностей;
    \item \textbf{fpclass\_tag\_def::subnormal} --- тэг, указывающий, что число может быть только денормализованным (ноль в данном случае не считается денормализованным числом);
    \item \textbf{fpclass\_tag\_def::zero} --- тэг, указывающий, что число может быть только одним из двух нулей;
    \item \textbf{fpclass\_tag\_def::normal} --- тэг, указывающий, что число может быть только нормализованным;
    \item \textbf{fpclass\_tag\_def::special} --- тэг, указывающий, что число может быть NaN или одной из бесконечностей;
    \item \textbf{fpclass\_tag\_def::general} --- тэг, указывающий, что число может быть любого из 5-ти классов.
\end{itemize}

Тэги можно комбинировать с помощью побитовых логических операторов.
Так чтобы получить тэг, указывающий, что число может быть денормализованным или нулем (к примеру предполагается работа только с малыми числами исходя из самой задачи), можно написать \textbf{fpclass\_tag\_def::subnormal | fpclass\_tag\_def::subnormal}, что число не принимает специальных значений -- \textbf{$\sim$fpclass\_tag\_def::special}.

\section{frexp}

\textbf{frexp} (\textbf{fr}action \textbf{exp}onent) -- это функция, которая разделяет число с плавающей точкой на нормализованную дробь и экспоненту.

\begin{equation*}
    arg = fraction \cdot 2^{exponent}
\end{equation*}

Стоит заметить, что понятие нормализованной дроби в стандарте C++ отличается от понятия мантисса в стандарте IEEE 754.
Согласно стандарту C++ нормализованная дробь должна принадлежать полуинтервалу $[0.5, 1)$, мантисса же нормализованного числа принадлежит интервалу $[1, 2)$.
Из-за этого разнится трактовка значения экспоненты.
В случае нормализованных чисел, экспонента возвращаемая функцией frexp на единицу больше экспоненты рассматриваемой в секции, посвященной представлению чисел с плавающей точкой (секции~\ref{sec::ieee}).
Если число денормализованное, экспонента будет отличаться от записанной в представлении на большее значение, так как необходимо дополнительно нормализовать мантиссу.

Так как данная функция должна возвращать два значения, в стандарте C++ был предложен следующий интерфейс: дробь является возвращаемым значением, а экспонента записывается по указателю переданному дополнительным аргументом.

\begin{lstlisting}[caption={Объявления перегрузок функции frexp согласно стандарту C++ 2011},captionpos=b,language=C++]
double frexp ( double arg, int* exp );
float frexp ( float arg, int* exp );
long double frexp ( long double arg, int* exp );
\end{lstlisting}

Но в языке CM невозможно взять указатель на вектор или матрицу, в связи с этим было решено использовать ссылочные типы vector\_ref и matrix\_ref для возвращения значения экспоненты из функции.
Таким образом, были предложены следующие интерфейсы:

\begin{lstlisting}[caption={Объявления перегрузок функции frexp в стандартной библиотеке языка CM},captionpos=b,language=C++]
template<typename FloatT, typename IntT, int width,
    typename FPClassTag = hint::fpclass_tag_def::general_t>
vector<FloatT, width>
frexp(vector<FloatT, width> arg, vector_ref<IntT, width> exp,
    FPClassTag = hint::fpclass_tag_def::general);


template<typename FloatT, typename IntT, int width, int hight,
    typename FPClassTag = hint::fpclass_tag_def::general_t>
matrix<FloatT, hight, width>
frexp(matrix<FloatT, hight, width> arg,
    matrix_ref<IntT, hight, width> exp,
    FPClassTag tag = hint::fpclass_tag_def::general);
\end{lstlisting}

Для того чтобы обработать денормализованные числа одновременно с нормализованными был использован следующий подход.
Денормализованные элементы вектора искусственно нормализовывались -- умножались на специальную константу ''нормализатор'' , число равное степени двойки, такую что произведение всегда является нормализованным числом.
Для выполнения данного условия степень должна превышать битовый размер поля дроби в кодировке и не быть излишне большой, чтобы не вызывать переполнения.
Для чисел двойной точности был выбран ''нормализатор'' равный $2^{54}$, минимальное возможное значение $2^{52}$, для чисел одинарной точности -- $2^{25}$ с минимально возможным $2^{23}$.
Соответствующие константы $54=\log_{2}2^{54}$ и $25=\log_{2}2^{25}$ были вычтены из итогового значения экспоненты, полученного для нормализованного числа.

Чтобы получить значение экспоненты для нормализованного числа была использована вспомогательная функция \textbf{get\_exp}, результат был увеличен на 1.
Чтобы получить нормализованную дробь в нормализованные описанным выше подходом числа (если число было изначально нормализованным, оно не нормализовывалось) записывалось значение экспоненты, равное -1, для этого была использована вспомогательная функция \textbf{set\_exp}.

Особые случаи -- $\pm 0$, $\pm \infty$, NaN -- были обработаны отдельно.

\section{clamp}

В отличие от указанных выше функций, функция clamp не является частью математической библиотеки языка C++.
Данная функция является частью библиотеки алгоритмов, причем данная функция была внесена в стандарт в только в 2017 году\cite{c++17}.

Функция clamp позволяет ограничить аргумент \textit{arg} сверху и снизу. 
Если \textit{arg} превышает барьер сверху \textit{high} (\textit{arg} > \textit{high}), возвращается значение барьера сверху, если нижний (\textit{arg} < \textit{low}) -- возвращается \textit{low}.
Если \textit{arg} принадлежит отрезку [\textit{low}, \textit{high}], то возвращается значение \textit{arg} без изменений.

\begin{lstlisting}[caption={Объявления шаблонной функции clamp согласно стандарту C++ 2017},captionpos=b,language=C++]
template<class T>
constexpr const T& clamp( const T& v,
    const T& lo, const T& hi );
\end{lstlisting}

Как и с предыдущими функциями, было предложено реализовать векторный вариант данной функции в рамках математической библиотеки языка CM.
В рамках архитектуры \foreignlanguage{english}{Intel Processor Graphics} данную функцию можно реализовать оптимально, используя всего две инструкции \textbf{MIN\_MAX}.
Данной инструкции в языке CM соответствуют две встроенные функции: \textbf{cm\_min} и \textbf{cm\_max}.

\begin{lstlisting}[caption={Объявления шаблонной функции clamp в математической библиотеке языка CM},captionpos=b,language=C++]
template<typename T, int width>
vector<T, width>
clamp(vector<T, width> arg, vector<T, width> lo, vector<T, width> hi) {
  arg = cm_min<T>(arg, hi);
  arg = cm_max<T>(arg, lo);
  return arg;
}

template<typename T, int width>
vector<T, width>
clamp(vector<T, width> arg, T lo, T hi) {
  vector<T, width> vec_lo = lo;
  vector<T, width> vec_hi = hi;
  return clamp(arg, vec_lo, vec_hi);
}
\end{lstlisting}

