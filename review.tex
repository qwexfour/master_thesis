\chapter{Обзор литературы}

Литература, посвященная математическим аппроксимациям довольно обширна, большая ее часть
представлена англоязычными материалами без официальных переводов на русский язык.

Вопросы аппроксимации исследовались математиками задолго до появления первых компьютеров.
Особую значимость в данной области имеют открытия Исаака Ньютона 1643-1727 (интерполяционные формулы
Ньютона), Жозефа Луи Лагранжа 1736-1813 (интерполяционный многочлен Лагранжа), Пафнутия Львовича
Чебышева 1821-1894 (полиномы Чебышева) и многих других математиков.

Первые крупные книги посвященные не только математической аппроксимации, но и ее применению
в компьютерных вычислениях появились только во второй половине двадцатого века, одновременно с
появлением вычислительных модулей арифметики с плавающей точкой. Одной из первых таких книг стала
работа Джона Фрейзера Харта <<\foreignlanguage{english}{Computer Approximations}>>\cite{hart}.
Первая публикация данной книги датируется 1968 годом.
В своей работе Джон Харт дает теоретический экскурс в предмет математической
аппроксимации, приводит основные теоремы, а также некоторые последние на момент публикации книги
теоретические открытия. После рассмотрения основной теории, автор переходит к вопросам реализации
изложенных алгоритмов на реальных вычислительных устройствах, построению математических подпрограмм.
Джон Харт рассматривает как особенности аппаратуры влияют на выбор оптимального алгоритма,
например, как очень высокая или наоборот очень низкая стоимость деления влияет на стоимость
применения рациональной
аппроксимации.
Также хочется отметить утверждение Харта от том, что построение производительных математических
подпрограмм возможно не только на ассемблере, но и на высокоуровневых языках программирования.
Многие узконаправленные советы и рекомендации Джона Харта в его книге, конечно же, устарели за
прошедшую половину века, так Харт рекомендует все операции, не зависящие от индуктивной переменной
цикла, выносить из данного цикла, что при современном развитии компиляторов конечно же делают последние
самостоятельно. Однако некоторые общие советы по проектированию подпрограмм, особенно касающиеся
применения теоретических изысканий и спустя 50 лет являются актуальными. Одна из важных мыслей поднятая
Джоном Хартом в его книге заключается в том, что для достижения наибольшей производительности и точности
вычислений математических функций, нужно максимально использовать в алгоритме математические свойства
данных функций.

Еще одной важной работой в рассматриваемой области стала книга Вильема Коди и Вильема Вейта <<\foreignlanguage{english}{Sofware Manual for Elementary Functions}>>\cite{cody-waite}.
В ней авторы предложили свои варианты алгоритмов подсчета основных математических функций.
Были рассмотрены отдельно алгоритмы для представления чисел с плавающей точкой по основанию системы счисления 2 и 10.
Широкое применение получил, предложенный Коди и Вейтом алгоритм сокращения рассматриваемой области функции.

Значительную роль в развитии вычислительных задач и в частности математических библиотек сыграло принятие в 1985 IEEE стандарта арифметики с плавающей точкой -- IEEE 754\cite{ieee754}.
Стандарт задает битовое представление чисел с плавающей точкой одинарной и двойной точности, операции над данными числами, гарантии по результатам данных операций, особые значения, исключения и многие другие составляющие арифметики с плавающей точкой, которые  до принятия стандарта сильно варьировались в конкретных реализациях, что доставляло дополнительные неудобства разработчикам вычислительных приложений.

Важность нового стандарта и важность в целом понимания особенностей разработки приложений с использованием арифметики с плавающей точкой прекрасно понимал Дэвид Голдберг.
В 1991 году в журнале <<\foreignlanguage{english}{ACM Computing Surveys}>> вышла его статья <<\foreignlanguage{english}{What Every Computer Scientist Should Know About Floating-Point Arithmetic}>>.
В данной статье Голдберг относительно кратко излагает основные составляющие стандарта IEEE 754, анализирует неточности которые могут возникать при вычислениях с использованием чисел с плавающей точкой, методы сокращения данных неточностей.
В значительно больших деталях анализ стандарта арифметики с плавающей точкой и проблем данной арифметики в целом можно найти в книге <<\foreignlanguage{english}{Handbook of Floating-Point Arithmetic}>>\cite{muller-fp} за авторством 9 человек, одним из которых является \foreignlanguage{english}{IEEE fellow} Жан-Мишель Мюллер.

Второй значимой работой Жан-Мишель Мюллера является его книга <<\foreignlanguage{english}{Elementary Functions: Algorithms and Implementation}>>.
В отличие от предыдущей представленной в данной книге внимание автора сконцентрировано именно на реализации функций математической библиотеки.
Жан-Мишель Мюллер отдельно рассматривает три основных подхода к реализации трансцендентных функций: рациональные приближения, CORDIC и вычисления с помощью заготовленных таблиц.

Одним из последних крупных изданий в рассматриваемой области является книга Нельсона Биба <<\foreignlanguage{english}{The Mathematical-Function Computation Handbook Programming Using the MathCW Portable Software Library}>>\cite{beebe}.
В ней рассматриваются конкретные решения принятые при проектировании библиотеки \foreignlanguage{english}{MathCW}.
Автор отталкивается от основных идей, заложенных Коди и Вейдом и расширяет их в своей реализации.


\section{Битовое представление чисел с плавающей точкой согласно IEEE 754}
\label{sec::ieee}

Произвольное число с плавающей точкой можно представить в следующем виде:

\begin{gather}
    (-1)^s \times d_{0}.d_{1}d_{2}d_{3}\ldots d_{p-1} \times \beta ^e
\intertext{где:}
\begin{tabular}{lcl}
     $\beta$ & --- & основание системы счисления \\
     $p$ & --- & точность представления \\
     $d_{i}$ & --- & цифра в системе счисления $\beta$ \\
     $e$ & --- & целое число, $e \in [e_{min}, e_{max}]$ \\
     $s$ & --- & знак: 0 для положительных чисел, 1 --- для отрицательных.
\end{tabular} \nonumber
\end{gather}

Число $d_{0}.d_{1}d_{2}d_{3}\ldots d_{p-1}$ называют мантиссой, а число $e$ --- экспонентой.
Если $d_{0} \neq 0$, то представление называется нормализованным.

В данной работе рассматриваются числа с плавающей точкой по основанию 2, так как только они реализованы в архитектуре \foreignlanguage{english}{Intel Processor Graphics}. В случае двоичной системы счисления представление нормализованного числа имеет следующий вид:

\begin{equation}
    (-1)^s \times 1.d_{1}d_{2}d_{3}\ldots d_{p-1} \times 2^e
\end{equation}

Как легко заметить, целая часть мантиссы в случае нормализованного представления для двоичной системы счисления всегда равна единице.
Данную единицу также часто называют неявной единицей.
Этот факт позволяет не тратить один бит представления на этот знак.
Этот бит называют скрытым битом.
Также легко заметить что нормализованным числом невозможно выразить ноль.
Поэтому наряду с нормализованным представлением применяют денормализованное.
В стандарте IEEE 754\cite{ieee754} для денормализованных чисел выделено специальное значение экспоненты равное $e_{min} - 1$.
Денормализованное число можно представить в виде:

\begin{equation}
    (-1)^s \times 0.d_{1}d_{2}d_{3}\ldots d_{p-1} \times 2^{e_{min}}
\end{equation}

Соответственно, когда все знаки $d_{i}$ равны нулю, представление выражает значение ноль.
Знаковый бит при таком представлении может быть как выставлен так и нет, поэтому согласно стандарту существует как положительное, так и отрицательное нулевое значение, но они между собой равны.
Следует заметить, что хоть и в битовом представлении записывается $e_{min} - 1$, основание системы счисления возводится в степень $e_{min}$.

Также следует отметить, что денормализованное представление не только предоставляет ноль и близкие к нулю значения, которые невозможно было получить нормализованным представлением при той же битности представления.
Наличие денормализованных чисел позволяет сохранить важный математический критерий для операции вычитания --- два числа равны тогда и только тогда, когда разница этих чисел равна нулю:

\begin{equation}
    (a = b) \equiv (a - b = 0)
\end{equation}

Помимо нормализованных, денормализавнных значений и нуля (технически ноль можно считать одним из денормализованных чисел, но принято рассматривать ноль как отдельный класс чисел с плавающей точкой) стандарт вводит два дополнительных значения: бесконечность (отрицательная и положительная) и \foreignlanguage{english}{NaN (Not a Number)}.
Значение бесконечности как правило можно получить при переполнении числа, NaN --- в результате операций, результат которых не определен.
Например, справедливы следующие соотношения:

\begin{align*}
    1 / 0 &= \infty \\
    -1 / 0 &= -\infty \\
    \infty + (- \infty) &= \text{NaN} \\
    0 \times \infty &= \text{NaN} \\
    0 / 0 &= \text{NaN} \\
    \infty / \infty &= \text{NaN}
\end{align*}

Для представления бесконечностей и NaN согласно стандарту отведено специальное значение экспоненты, равное $e_{max} + 1$.
Для бесконечностей отведено значение дробной части мантиссы равное нулю, все остальные значения кодируют NaN.

Следует отметить, что для чисел с плавающей точкой помимо переполнения сверху --- ситуации, в которой результат операции превышает по абсолютной величине максимально представимое число, выделяется переполнение снизу --- ситуация, в которой результат операции по абсолютной величине меньше минимального представимого положительного числа.
Если результате переполнения сверху результатом операции становится бесконечность, то в случае переполнения снизу результат операции обращается в ноль.

Для чисел одинарной и двойной точности стандарт определяет конкретное битовое представление.
Старший бит отведен под знак, далее идет $n = \log_2(e_{max} - e_{min} + 2)$ бит экспоненты, младшие $m = p-1$ бит отведены для дробной части мантиссы $d_{1}d_{2}d_{3}\ldots d_{p-1}$.
Конкретные размеры битовых полей можно посмотреть в таблице~\ref{tab:ieee_bit_size_common}.

\begin{table}[h]
    \centering
    \begin{tabular}{r||c|c|c|c}
        точность  & всего & знак & экспонента, $n$ & дробь, $m$ \\
        \hline\hline
        единичная & 32    & 1    & 8               & 23    \\
        \hline
        двойная   & 64    & 1    & 11              & 52    \\
    \end{tabular}
    \caption{Битовые размеры полей в кодировке чисел с плавающей точкой единичной и двойной точности согласно стандарту IEEE 754}
    \label{tab:ieee_bit_size_common}
\end{table}

Для записи отрицательных значений экспоненты используется схема со смещением.
В отведенные под экспоненту биты записывается не сама экспонента, а значение, полученное в результате суммы значения экспоненты и некоторого заранее установленного смещения: $biased\_e = e + bias$.
Значение $biased\_e$ представлено целочисленным беззнаковым целым типом.
Минимальное (нулевое) значение смещенной экспоненты $biased\_e$, которое соответствует определенному выше значению $e_{min} - 1$, отведено под денормализованные числа и ноль.
Максимальное значение смещенной экспоненты $biased\_e$, которое соответствует определенному выше значению $e_{max} + 1$, отведено под бесконечности и NaN.
Соответственно, максимальные и минимальные значения смещенной и не смещенной экспоненты можно соотнести следующими равенствами:

\begin{align*}
    &biased\_e_{min} = (e_{min} - 1) + bias = 0 \\
    &biased\_e_{max} = (e_{max} + 1) + bias = 2^n - 1
\end{align*}

Конкретные значения смещения, минимальные и максимальные значения экспоненты для типов одинарной и двойной точности приведены в таблице~\ref{tab:ieee_bit_size_exp}.

\begin{table}[h]
    \centering
    \begin{tabular}{r||c|c|c|c|c}
        точность  & $bias$ & $e_{min}$ & $e_{max}$ & $biased\_e_{min}$ & $biased\_e_{max}$ \\
        \hline\hline
        одинарная & 127    & -126      & 127       & 0                 & 255 \\
        \hline
        двойная   & 1023   & -1022     & 1023      & 0                 & 2047
    \end{tabular}
    \caption{Смещение, минимальные и максимальные значения экспоненты для типов одинарной и двойной точности согласно стандарту IEEE 754}
    \label{tab:ieee_bit_size_exp}
\end{table}

Все пять категорий чисел с плавающей точкой (ноль, денормализованное число, бесконечность, NaN, нормализованное число) можно определить основываясь на значениях, записанных в полях экспоненты и дроби.

\begin{table}[h]
    \centering
    \begin{tabular}{>{\centering}p{0.3\textwidth}||>{\centering}p{0.2\textwidth}|>{\centering}p{0.2\textwidth}|>{\centering\arraybackslash}p{0.2\textwidth}}
        \backslashbox{дробь}{экспонента} & 0 & $biased\_e_{max}$ & иначе \\
        \hline\hline
        0               & ноль & бесконечность & \multirow{2}*{норм. число}\\
        \cline{1-3}
        иначе           & денорм. число & NaN &
    \end{tabular}
    \caption{Класс числа с плавающей точкой в зависимости от значения дроби и экспоненты}
    \label{tab:ieee_classify}
\end{table}

\subsubsection{ULP}

\textbf{ULP} (\foreignlanguage{english}{\textbf{U}nit in the \textbf{L}ast \textbf{P}lace}) --- функция, отражающая "вес" последнего бита в мантиссе числа с плавающей точкой.
Данная функция широко используется для оценки ошибок операций над числами с плавающей точкой\cite[с.~32]{muller-fp}.
Термин был изначально введен Уильямом Каханом в 1960 году.
Согласно ему:

\begin{displayquote}
    Функция $ULP(x)$ равна расстоянию между двумя числами с плавающей точкой, ближайшими к значению $x$, даже если $x$ --- одно из них.
\end{displayquote}

Отмечу, что в качестве аргумента функции предполагается действительное число, то есть число известное с бесконечной точностью, а не число с плавающей точкой.
Функция ULP своя для каждого представления числа с плавающей точкой (для чисел двойной точности ее значение будет меньше чем для чисел одинарной точности).
Ошибка операции с правильным округлением до ближайшего числа не может превышать $\frac{1}{2}$ULP.

\section{\foreignlanguage{english}{GEN Virtual ISA}}

\foreignlanguage{english}{Intel Processor Graphics} --- это общее название для серии созданных компанией Intel графических архитектур.
Для указания конкретной архитектуры конкретного устройства используется номер поколения, или сокращенно с английского Gen.
Так процессоры Intel 10-ого поколения (кодовое имя Ice Lake) имеют встроенный графический процессор с архитектурой 11-ого поколения (Gen11), с 6-ого по 8-ое поколение (например используемый в данной работе для замеров производительности Sky Lake) --- Gen9.

В каждом отдельном поколении набор инструкций варьируется, не всегда сохраняется обратная совместимость между более новыми и более старыми архитектурами.
Поэтому для удобства разработки компиляторов, а также написания ассемблерных вставок было создано промежуточное представление \foreignlanguage{english}{GEN Virtual ISA}, или сокращенно vISA\cite{visa}.
Данное представление является общим для \foreignlanguage{english}{Intel Processor Graphics} архитектур 8-11-ого поколения.
Оно представляет из себя ассемблер во многом схожий с ассемблерами конкретных поколений, некоторое их усреднение, однако используются некоторые более высокоуровневые абстракции по сравнению с ассемблером конечной архитектуры (так например вместо ограниченного количества физических регистров используется условно-бесконечное число виртуальных регистров или переменных) и некоторые другие изменения.

Соответственно, рассмотрение архитектуры  \foreignlanguage{english}{Intel Processor Graphics} будет сведено к рассмотрению vISA, так как данное промежуточное представление отражает основные особенности рассматриваемой архитектуры.

\subsection{Типы данных}
\label{par:visa:types}

vISA поддерживает все основные используемые в программировании типы данных (таблица~\ref{tab:visa::types}).
Следует отметить, что в vISA в отличие от большинства ассемблеров тип данных является атрибутом не инструкции, а регистра.

\begin{table}[h]
    \centering
    \begin{tabular}{>{\raggedleft}p{0.4\textwidth}|>{\centering}p{0.1\textwidth}|>{\raggedright\arraybackslash}p{0.2\textwidth}}
        тип данных & размер, бит & текстовое представление \\
        \hline\hline
        беззнаковый байт             & 8 & UB \\
        \hline
        знаковый байт                & 8 & B \\
        \hline
        беззнаковое слово            & 16 & UW \\
        \hline
        знаковое слово               & 16 & W \\
        \hline
        беззнаковое двойное слово    & 32 & UD \\
        \hline
        знаковое двойное слово       & 32 & D \\
        \hline
        беззнаковое четверное слово & 64 & UQ \\
        \hline
        знаковое четверное слово    & 64 & Q \\
        \hline
        число с плавающей точкой
        половинной точности          & 16 & HF \\
        \hline
        число с плавающей точкой
        единичной точности           & 32 & F \\
        \hline
        число с плавающей точкой 
        двойной точности             & 64 & DF \\
        \hline
        булев тип                    & 1 & BOOL \\
        \hline
        пакетированный беззнаковый
        целочисленный вектор         & 32 & UV \\
        \hline
        пакетированный знаковый 
        целочисленный вектор         & 32 & V \\
        \hline
        пакетированный знаковый 
        дробный вектор               & 32 & VF
    \end{tabular}
    \caption{Типы в vISA}
    \label{tab:visa::types}
\end{table}

Упакованные типы (V, UV, VF) предназначены для передачи векторных констант в качестве непосредственного операнда в инструкцию.
Так как размер, который выделяется на такой операнд ограничен, а необходимо передать целый вектор данных, на один элемент вектора остается бит меньше, чем в любом выше описанном типе.
В случае целочисленного вектора в одном 32-битном числе кодируется 8 значений, что дает 4 бита на один элемент, что в свою очередь соответствует отрезку значений $[0, 15]$ для беззнакового числа и $[-8, 7]$ --- для знакового.
Дробный же пакетированный тип состоит из 4 элементов, соответственно, 8 бит каждый.

Булев тип представим только как тип элемента предикатных регистров --- специальные 32-битные регистры, представляющие вектор из 32-ух булевых значений.

Представление чисел с плавающей точкой одинарной и двойной точности соответствует стандарту IEEE 754-1985\cite{ieee754}, для чисел половинной точности --- IEEE 754-2008\cite{ieee754-2008}, однако в данной работе основной фокус будет направлен на первые два типа.

В vISA есть два режима исполнения операций над числами с плавающей точкой: IEEE и ALT.
Первый полностью соответствует стандарту IEEE 754, за исключением двух пунктов:

\begin{itemize}
    \item Для чисел половинной точности результатом операции не может стать денормализованное число, происходит переполнение снизу;
    \item Для чисел одинарной и двойной точности во время исполнения можно выбрать использовать или нет денормализованное представление в вычислениях.
\end{itemize}

Более точно представление и операции над числами с плавающей точкой согласно стандарту IEEE 754 были рассмотрены в секции~\ref{sec::ieee}.

\subsection{Модель исполнения}
\label{par:visa:exec}

Как уже было упомянуто, \foreignlanguage{english}{Intel Processor Graphics} относится к векторным архитектурам --- операции производятся на векторами данных.
Операции над каждым отдельным элементом вектора производятся на своей полосе\cite[с.~271]{hennessy-patterson}.
Всего в каждом исполнительном устройстве архитектуры \foreignlanguage{english}{Intel Processor Graphics} есть 32 полосы.
Соответственно, за одну инструкцию можно обработать максимум 32 значения в параллель, вектор размером 32.
Чтобы определить конкретный размер вектора, количество используемых полос, в каждую инструкцию записывается число --- ширина инструкции (в оригинальной документации употребляется термин \foreignlanguage{english}{\textit{execution size}}).
Его возможные значения: 1, 2, 4, 8, 16, 32\cite{visa}.

Каждую отдельную полосу исполнения можно отключать.
Таким образом появляется возможность применять операции к векторам условно.
Для этого в архитектуре реализовано два подхода, которые можно совмещать.

Первый подход --- это предикатирование инструкций. 
Для большей части инструкции можно указать предикатный регистр, в зависимости от значения которого будут активироваться, или наоборот не активироваться некоторые полосы, соответственно, будет исполняться или не исполняться операция над некоторыми элементами вектора.

Второй подход --- это использование маски исполнения и инструкций потока управления.
Маска исполнения --- это особый предикатный регистр, значение которого неявно выставляют инструкции потока управления.
Во время исполнения каждой инструкции значение этого регистра считывается, и в зависимости от него активируются, или наоборот деактивируются некоторые полосы.

Аппаратура позволяет указывать какую именно часть предиката или маски исполнения необходимо использовать для конкретной инструкции.
Также возможно полностью отключить маску исполнения для конкретной инструкции: на активацию конкретных полос будет влиять только предикат.
Для поддержки данных возможностей в vISA для каждой инструкции указывается специальный атрибут.
В таблице~\ref{tab:visa:mask} указаны возможные значения данного атрибута.

\begin{table}[h]
    \centering
    \begin{tabular}{c|c|c}
        \makecell{атрибут \\ (маска учитывается)} & \makecell{атрибут \\ (маска игнорируется)} & смещение  \\
        \hline
        M1 & M1\_NM & 0 \\
        M2 & M2\_NM & 4 \\
        M3 & M3\_NM & 8 \\
        M4 & M4\_NM & 12 \\
        M5 & M5\_NM & 16 \\
        M6 & M6\_NM & 20 \\
        M7 & M7\_NM & 24 \\
        M8 & M8\_NM & 28
    \end{tabular}
    \caption{Атрибут маски исполнения}
    \label{tab:visa:mask}
\end{table}

Наличие "\_NM" в атрибуте означает, что маска исполнения не будет учитываться при выполнении инструкции, отсутствие -- наоборот, что будет.
Номер атрибута соответствует начальному смещению одновременно и в явном предикате и в маске исполнения.

Таким образом, по смещению и ширине инструкции определяется какая часть маски или предиката будет использована.
Например, для атрибута M3\_NM (смещение 8) и ширине инструкции 8 получаем, что будут использоваться с 8-ого по 15-ый включительно биты предиката.
Очевидно, что не все комбинации атрибута и размера исполнения возможны, сумма смещения и ширины инструкции не должна превышать размер предикатного регистра, равный 32.


\subsection{Операнды}

vISA имеет широкий набор различных операндов.
Два больших класса операндов --- это простые (в оригинальной документации используется термин \textit{raw}) операнды и векторные операнды.
Последние в свою очередь подразделяются на базовые (в оригинальной документации используется термин \textit{general}), адресные, косвенные, непосредственные (были частично рассмотрены в параграфе~\ref{par:visa:types}), предикатные (были частично рассмотрены в параграфе~\ref{par:visa:exec}) и статусные.
В данном параграфе будут рассмотрены только базовые векторные операнды, так как только они, по большей части, будут использованы в данной работе.

Виртуальные векторные регистры в vISA задаются двумя параметрами: тип и количество элементов.
Виртуальный регистр в некоторых случаях может трактоваться не как вектор, а как матрица, размер строки которой в байтах равен размеру физического регистра.
Последняя строка такой матрицы может быть заполнена не до конца, если размер виртуального векторного регистра не кратен размеру физического регистра.

Если два регистра имеют одинаковый размер в байтах, то их можно объединить так, чтобы они ссылались но одни и те же данные.
Например, можно объединить вектор из 4 знаковых 32-битных целых и 8 беззнаковых 16-битных целых, что позволит к примеру класть в данный регистр знаковые числа, но в дальнейшем работать отдельно с их младшими и старшими 16-тью битами.

Для того чтобы обращаться к отдельным элементам векторных регистров в базовых векторных операндах применяют адресацию регионами.
Адресация входных операндов и результата отличается.
Регион входного операнда в некотором смысле логически выделяет в векторном регистре подматрицу.
Такой регион задается размером исполнения и 5-тью параметрами векторного операнда:

\begin{lstlisting}[caption=Пример базового векторного входного операнда, captionpos=b]
    V42(row,column)<vstride;width,stride>
\end{lstlisting}

\begin{itemize}
    \item номер строки (row) --- номер строки в описанном выше представлении виртуального регистра матрицей, индексация начинается с нуля;
    \item смещение в строке (column) --- смещение в строке выраженное в числе элементов;
    \item горизонтальный шаг (stride) --- шаг, выраженный в числе элементов, с которым необходимо брать элементы из регистра, чтобы сформировать строку матрицы;
    \item ширина (width) --- размер строки, число элементов в ней;
    \item вертикальный шаг (vstride) --- расстояние, выраженное в числе элементов, между двумя элементами вектора, являющимися соответствующими элементами двух последовательных строк выделяемой матрицы (например, расстояние между нулевым элементом нулевой строки и нулевым элементом первой строки, или третьим элементом четвертой строки и третьим элементом пятой строки.
\end{itemize}

Число строк в выделенной подматрице определяется частным ширины инструкции и параметра ширины региона.
Следует также отметить, что регион представляется матрицей чисто для удобства человеческого восприятия и терминологии. Реальные вычисления не являются матричными, матрица сводится к одномерной последовательности своих строк, что означает, что возможно складывать матрицы (регионы) с различными линейными размерами, если число элементов в них одинаково.

\begin{multline}
    \begin{pmatrix} a_{00} & a_{01} & a_{02} \\ a_{10} & a_{11} & a_{12} \end{pmatrix} +
    \begin{pmatrix} b_{00} \\ b_{10} \\ b_{20} \\ b_{30} \\ b_{40} \\ b_{50} \end{pmatrix} +
    \begin{pmatrix} c_{00} & c_{01} \\ c_{10} & c_{11} \\ c_{20} & c_{21} \end{pmatrix} = \\
    \begin{pmatrix} a_{00} & a_{01} & a_{02} & a_{10} & a_{11} & a_{12} \end{pmatrix} + \\
    \begin{pmatrix} b_{00} & b_{10} & b_{20} & b_{30} & b_{40} & b_{50} \end{pmatrix} + \\
    \begin{pmatrix} c_{00} & c_{01} & c_{10} & c_{11} & c_{20} & c_{21} \end{pmatrix} = \\
    \begin{pmatrix} a_{00} \\ a_{01} \\ a_{02} \\ a_{10} \\ a_{11} \\ a_{12} \end{pmatrix} +
    \begin{pmatrix} b_{00} \\ b_{10} \\ b_{20} \\ b_{30} \\ b_{40} \\ b_{50} \end{pmatrix} +
    \begin{pmatrix} c_{00} \\ c_{01} \\ c_{10} \\ c_{11} \\ c_{20} \\ c_{21} \end{pmatrix} =
    \begin{pmatrix} a_{00} + b_{00} + c_{00} \\ a_{01} + b_{10} + c_{01} \\ a_{02} + b_{20} + c_{10} \\ a_{10} + b_{30} + c_{11} \\ a_{11} + b_{40} + c_{20} \\ a_{11} + b_{40} + c_{20} \\ a_{12} + b_{50} + c_{21} \end{pmatrix}
\end{multline}

Регион результата упрощен и представляет из себя одномерный вектор.
Он задаётся всего 3-мя параметрами.
Параметры полностью соответствую аналогичным для входного операнда.

\begin{lstlisting}[caption=Пример базового векторного операнда результата, captionpos=b]
    V23(row,column)<stride>
\end{lstlisting}

Существуют определенные ограничения на адресацию в виртуальных регистрах.

\begin{itemize}
    \item Возможные значения параметра width: 1, 2, 4, 8, 16;
    \item Возможные значения параметра vstride: 0, 1, 2, 4, 8, 16, 32;
    \item Возможные значения параметра stride: 0, 1, 2, 4;
    \item Для результата параметр stride не может ровняться 0;
    \item Размер исполнения должен быть больше параметра width;
    \item Регион не может покрывать больше чем две строки виртуального регистра, то есть два физических регистра.
\end{itemize}

\subsection{Инструкции}

В vISA представлены порядка сотни инструкций.
Среди них есть как инструкции специально предназначенные работы с графикой и 3D, так и инструкции общего назначения: арифметические, логические, инструкции для работы с памятью, инструкции синхронизации и так далее.

Рассмотрим одну из самых простых и самых часто встречаемых инструкций --- инструкцию MOV.
Текстовое представление данной инструкции выглядит следующим образом:

\begin{lstlisting}
[(<P>)] MOV [.sat] (<exec_size>, <mask_attr>) <dst> <src>
\end{lstlisting}

\begin{itemize}
    \item exec\_size --- ширина инструкции;
    \item mask\_attr --- атрибут маски исполнения (M1, M1\_NM, M2, M2\_NM, \ldots);
    \item P --- предикатный регистр, он может как присутствовать так и отсутствовать (предикатирование рассмотрено в параграфе~\ref{par:visa:exec});
    \item src --- входной операнд;
    \item dst --- операнд результата;
    \item sat --- атрибут насыщения, он может как присутствовать так и отсутствовать, данный атрибут может изменять семантику переполнения для некоторых типов в некоторых инструкциях.
\end{itemize}

\begin{lstlisting}[caption = {Пример инструкции MOV}, captionpos=b, label=lst:visa:mov]
    (P1)   MOV (8, M1_NM) V23(1,1)<2> V42(0,0)<16;4;2>
\end{lstlisting}

\section{Язык \foreignlanguage{english}{C for Metal (CM)}}

Язык \foreignlanguage{english}{C for Metal}, будучи основанным на языке C++, поддерживает все основные скалярные типы: int, unsigned, float, double, char и так далее.
Особенностью данного языка является введение дополнительных встроенных типов: vector и matrix - для представления векторов и матриц значений, соответственно.
Элементы векторов или матриц могут быть любого поддержанного скалярного типа.
Объявление переменных векторного и матричного типа выглядят в коде следующим образом:

\begin{lstlisting}[language=C++]
vector<int, 16> v;
matrix<float, 4, 8> m;
\end{lstlisting}

Для вектора в качестве шаблонных параметров указывается тип элемента и размер вектора, для матрицы -- тип элемента, число строк и число столбцов.

Компилятором гарантируется, что объекты данных типов будут представлены виртуальными векторными регистрами в итоговом vISA ассемблере.
Не обязательно, что каждой отдельной переменной будет соответствовать отдельный виртуальный регистр, в результате оптимизаций несколько переменных оригинального кода могут быть объединены в один регистр, или же наоборот одна переменная может быть разделена на несколько регистров, логическое значение может перемещаться между несколькими регистрами, или вообще объединено с другим значением, но в том или ином виде переменная окажется в виртуальном регистровом файле.
В некотором смысле, рассматриваемые векторные и матричные типы являются абстракцией виртуального векторного регистра.

Для получения доступа к возможностям адресации регионами в векторном регистре на уровне абстракции языка CM, для встроенных векторных и матричных типов были добавлены методы select.
Данные методы позволяют выбирать некоторые подмножества элементов вектора или матрицы.
Число параметров для случая вектора и матрицы отличается.

\begin{lstlisting}
vector<int, h_size> subv =
    v.select<h_size, h_stride>(h_offset);
matrix<float, v_size, h_size> subm =
    m.select<v_size, v_stride, h_size, h_stride>(v_offset,
                                                 h_offset);
\end{lstlisting}

В рассмотренном примере:

\begin{itemize}
    \item \textit{h\_size} --- число выбираемых элементов по горизонтали, или, иными словами, количество столбцов в выбранной подматрице, или размер подвектора в случае с вектором;
    \item \textit{h\_stride} --- шаг по горизонтали, с которым выбираются элементы из матрицы или вектора, или, иными словами расстояние между последовательными элементами одной строки подматрицы в оригинальной матрице, аналогично расстояние между последовательными элементами подвектора в оригинальном векторе;
    \item \textit{h\_offset} --- индекс первого элемента, с которого будет начинаться подмножество, по горизонтали;
    \item \textit{v\_size} --- число выбираемых элементов по вертикали, или, иными словами, количество строк в выбранной подматрице;
    \item \textit{v\_stride} --- шаг по вертикали, с которым выбираются строчки из оригинальной матрицы, или, иными словами, расстояние по вертикали между двумя последовательными элементами одного столбца подматрицы в оригинальной матрице;
    \item \textit{v\_offset} --- индекс первого элемента, с которого будет начинаться подмножество, по вертикали.
\end{itemize}

Параметры \textit{h\_size}, \textit{h\_stride}, \textit{v\_size}, \textit{v\_stride} обязаны быть константами времени компиляции, \textit{h\_offset} и \textit{v\_offset} могут определяться в ходе исполнения.

Для доступа к возможности связывания двух виртуальных векторных регистров разного типа данных, но одинакового суммарного размера был введен метод format.
Данный метод позволяет изменять то, как какой тип трактуются данные матрицы или вектора, изменять соотношение числа столбцов и строк в матрице, приводить матрицу к вектору и вектор к матрице.

\begin{itemize}
    \item \verb|select<type, v_size, h_size>()| --- позволяет трактовать объект, для которого вызван, как объект типа \verb|matrix<type, v_size, h_size>|;
    \item \verb|select<type>()| --- позволяет трактовать объект, для которого вызван, как вектор с элементами типа \verb|type|, размер вектора определяется из числа элементов оригинального объекта.
\end{itemize}

Как метод select, так и метод format возвращают специальные ссылочные типы: vector\_ref, matrix\_ref.
Переменные данного типа не создают новый объект, они ссылаются на некоторые элементы уже существующего объекта, причем элементы могут трактоваться как элементы другого типа.

\begin{lstlisting}
vector<double, 8> vec;
vector_ref<int, 8> vec_ref =
    vec.select<4, 2>(0).format<int>();
\end{lstlisting}

Так в приведенном примере \textit{vec\_ref} ссылается на элементы вектора \textit{vec}, стоящие на четных позициях, и интерпретирует каждый элемент, который изначально имеет тип double, как пару элементов типа int.

Одним из способов получить предикатный код является использование метода merge.
Данный метод позволяет условно записать в некоторые элементы вектора или матрицы значения другого вектора или матрицы.
Записываются элементы, которые соответствуют выставленному значению переданной маски.

\begin{lstlisting}[language=C++]
vector<int, 8> a = .....;
vector<int, 8> b = .....;
a.merge(b, b > 0);
\end{lstlisting}

В приведенном примере в вектор \textit{a} запишутся только положительные элементы вектора \textit{b}.

Приведем пример кода, который мог бы быть оттранслирован в инструкцию из листинга~\ref{lst:visa:mov}:

\begin{lstlisting}[language=C++]
Vec23.select<8, 2>(17).merge(Mtx42.select<2,2,4,2>(0,0)
    .format<short>(), Cond1)
\end{lstlisting}