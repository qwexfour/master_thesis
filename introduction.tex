\chapter{Введение}

Современные задачи программирования требуют все большей производительности от аппаратуры и
оперируют все над большим объемом данных. Многие из данных задач обладают заложенным параллелизмом,
из-за чего в настоящее время всю большую популярность приобретает техника \foreignlanguage{english}{\textbf{GPGPU}
(\textbf{G}eneral-\textbf{P}urpose computing on \textbf{G}raphics \textbf{P}rocessing \textbf{U}nits)}.
Данная техника заключается в использовании графических процессоров для вычислений общего назначения.

Некоторые из задач, перекладываемых на графический процессор, являются математическими, расчетными,
оперирующими над арифметикой с плавающей точкой. Очень важным фактором для разработки данных приложений
является наличие точной высокопроизводительной оптимизированной под используемую архитектуру
стандартной математической библиотеки.

В рамках данной работы из всего множества реализуемых в стандартных математических библиотеках
функций будут рассмотрены только экспонента и логарифм. Будет произведен анализ существующих
алгоритмов нахождения экспоненты и логарифма, будут рассмотрены открытые реализаций функций подсчета экспоненты и логарифма и предложено решение
для \foreignlanguage{english}{Intel Processor Graphics} архитектуры.


%-----------------------------------------------------------------------%
\section{Архитектура \foreignlanguage{english}{Intel Processor Graphics}}
%-----------------------------------------------------------------------%

\foreignlanguage{english}{Intel Processor Graphics} является графической архитектурой.
Будучи таковой, она состоит из десятков исполнительных устройств.
Устройства объединены в сложную топологию с группами и подгруппами, некоторые ресурсы распределены между всеми устройствами, некоторые --- между группой устройств, существуют средства синхронизации и так далее.

Однако в данный аспект рассматриваемой архитектуры, особенности взаимодействия многих исполнительных устройств, не будет представлен в деталях, так как подсчет математических функций --- изолированная задача, выполнение подпрограммы подсчета функции на одном потоке никак не влияет на подсчет функции на другом потоке.
Такие подпрограммы даже не используют общих ресурсов, за исключением, быть может, таблиц с константами.

Таким образом, для выбранной задачи достаточно рассмотреть работу архитектуры в рамках одного потока, одного исполнительного устройства.
В таком упрощении исполнительное устройство можно воспринимать как обычный одноядерный процессор общего назначения со своим определенным набором команд и микроархитектурой.

\subsection{Векторные архитектуры}

\foreignlanguage{english}{Intel Processor Graphics} является \textbf{SIMD} (\foreignlanguage{english}{\textbf{S}ingle \textbf{I}nstruction \textbf{M}ultiple \textbf{D}ata}) архитектурой или, другими словами, векторной архитектурой.
В такой архитектуре операции производятся не над единичными данными (сложить два целых 32-битных числа, перемножить два числа с плавающей точкой двойной точности и так далее), а сразу над набором данных, над вектором данных (сложить два вектора, состоящих из 16-ти целых 32-битных чисел, перемножить поэлементно два вектора, состоящих из 8-ми чисел с плавающей точкой двойной точности и так далее).

В векторных архитектурах аналогично с \foreignlanguage{english}{\textbf{RISC} (\textbf{R}educed \textbf{I}nstruction \textbf{S}et \textbf{C}omputer)} архитектурой большинство операций не работают с памятью напрямую. Есть выделенные операции, которые могут загружать данные из памяти в специальные быстрые, но ограниченные в количестве ячейки памяти --- регистры (в случае с векторными процессорами загружать целые блоки данных в ячейки, в которых последовательно хранится вектор данных --- векторные регистры).
Такие операции как правило называют \textbf{LOAD}.
Второй вид выделенных операций --- \textbf{STORE}, они наоборот берут данные из регистров (векторных регистров) и записывают эти данные в память.
Остальные же операции работают напрямую с регистрами\cite[с.~264]{hennessy-patterson}.

Семантика операций над векторными регистрами в некоторых случаях соответствует семантике операций над векторами в линейной алгебре, например сложение векторов (формула \ref{genx:eq:add_vec}) и умножение вектора на число (формула \ref{genx:eq:mul_scl_vec}).

\begin{align}
    \label{genx:eq:add_vec}
    ADD(A, B) &= \begin{pmatrix} a_0 \\ a_1 \\ a_2 \\ a_3 \end{pmatrix} +
    \begin{pmatrix} b_0 \\ b_1 \\ b_2 \\ b_3 \end{pmatrix} =
    \begin{pmatrix} a_0 + b_0 \\ a_1 + b_1 \\ a_2 + b_2 \\ a_3 + b_3 \end{pmatrix} \\
    \label{genx:eq:mul_scl_vec}
    MUL(a, B) &= a \cdot
    \begin{pmatrix} b_0 \\ b_1 \\ b_2 \\ b_3 \end{pmatrix} =
    \begin{pmatrix} a \cdot b_0 \\ a \cdot b_1 \\ a \cdot b_2 \\ a \cdot b_3 \end{pmatrix}
\end{align}

Однако в большинстве случаев семантикой операции над векторами является поэлементное применение соответствующей скалярной операции.
Так для умножения и деления двух векторов можно записать соотношения \ref{genx:eq:mul_vec} и \ref{genx:eq:div_vec} соответственно.
\begin{align}
    \label{genx:eq:mul_vec}
    MUL(A, B) &= \begin{pmatrix} a_0 \\ a_1 \\ a_2 \\ a_3 \end{pmatrix} \cdot
    \begin{pmatrix} b_0 \\ b_1 \\ b_2 \\ b_3 \end{pmatrix} =
    \begin{pmatrix} a_0 \cdot b_0 \\ a_1 \cdot b_1 \\ a_2 \cdot b_2 \\ a_3 \cdot b_3 \end{pmatrix} \\
    \label{genx:eq:div_vec}
    DIV(A, B) &= \begin{pmatrix} a_0 \\ a_1 \\ a_2 \\ a_3 \end{pmatrix} /
    \begin{pmatrix} b_0 \\ b_1 \\ b_2 \\ b_3 \end{pmatrix} =
    \begin{pmatrix} a_0 / b_0 \\ a_1 / b_1 \\ a_2 / b_2 \\ a_3 / b_3 \end{pmatrix}
\end{align}

%-----------------------------------------------------------------------------------------------------%
\section{Проектирование приложений для архитектуры \foreignlanguage{english}{Intel Processor Graphics}}
%-----------------------------------------------------------------------------------------------------%

Графический процессор по своей задумке не может существовать в отрыве от центрального процессора.
Изначально такие системы были задуманы так, что существует главное управляющее устройство, часто употребляется термин хост (\textit{от англ.} host), и одно или несколько вспомогательных специализированных исполнительных устройств (device в английской литературе).
Управляющее устройство формирует задачи, распределяет их между исполнительными устройствами, во общем случае одним из таких устройств может быть само управляющее устройство, и в конечном итоге собирает результаты проделанной работы.
Так как в данных системах задействовано больше чем одна архитектура, они называются гетерогенными, а программирование для подобных систем --- гетерогенным программированием.

В большинстве случаев в качестве управляющего устройства выступает центральный процессор.
Для архитектуры центрального процессора, как правило, существует большое множество компиляторов различных языков программирования.
Поэтому большинство фреймворков для гетерогенного программирования, не вводят свой язык для написания кода управляющего устройства (хостового кода), а предоставляют библиотеку и ее программный интерфейс приложения или \textbf{API} (\foreignlanguage{english}{\textbf{A}pplication \textbf{P}rogramming \textbf{I}nterface}), как правило на языке C.
Пользователю остается возможность выбрать любой язык, поддерживающий данное \textbf{API}.
Данная библиотека называется рантайм библиотекой или библиотекой среды выполнения.
В ней реализованы все низкоуровневые механизмы, необходимые для взаимодействия управляющих и исполнительных устройств.


С написанием кода для устройств обратная ситуация. В данной области не успел сложиться устоявшийся набор языков программирования, поэтому каждый фреймворк предоставляет свое решение.
Однако большинство подобных решений основываются на существующих языках, зачастую C или C++, внося в них свой расширения и ограничивая существующий функционал, чтобы адаптировать язык к конечной платформе.

Для написания приложений общего назначения для архитектуры \foreignlanguage{english}{Intel Processor Graphics} применяются следующие языки: OpenCL, Data Parallel C++ (DPC++) и C for Metal (CM).


\subsection{OpenCL}

OpenCL является открытым промышленным стандартом гетерогенного программирования\cite{opencl20}.
В OpenCL применяется подход с раздельной компиляцией кода: отдельно пишется код для управляющего устройства, с использованием \textbf{API} библиотеки среды исполнения, отдельно -- для исполнительных устройств.

Язык для написания кода устройств также называется OpenCL.
Данный язык основан на языке C и реализует модель исполнения \textbf{SIMT} (\foreignlanguage{english}{\textbf{S}ingle \textbf{I}nstruction, \textbf{M}ultiple \textbf{T}hreads}).
То есть код пишется для некоторого одного элемента массива данных, код скалярный, а во время исполнения каждый отдельный поток, отдельное устройство, получает свою часть данных и работает с ней.

Возможна векторизация, если устройство поддерживает векторные команды.
В таком случае каждое исполнительное устройство будет исполнять не один поток, а несколько.
Векторизация производится компилятором языка OpenCL.


\subsection{Data Parallel C++ (DPC++)}

Data Parallel C++ является разработанным компанией Intel расширением языка SYCL.
DPC++ как и SYCL основывается на OpenCL.
В отличие от OpenCL данные языки предоставляют высокоуровневые интерфейсы на языке C++, которые позволяют писать хостовый код и код устройств в рамках одной единицы трансляции.
Что по сравнению с моделью OpenCL имеет как свои преимущества, например проверка типов, что было невозможно в раздельной модели OpenCL, так и свои недостатки, теперь пользователь ограничен использованием языка C++ для написания хостового кода.

Код устройств в DPC++, как и в OpenCL, пишится в модели SIMT, скалярно.

\subsection{C for Metal (CM)}

C for Metal или CM --- язык, спроектированный в компании Intel специально для архитектуры \foreignlanguage{english}{Intel Processor Graphics}.
В отличие от перечисленных выше языков данный язык использует явные векторные и матричные типы.
Сами типы и операции над ними спроектированы так, чтобы наиболее оптимально и полно использовать возможности рассматриваемой архитектуры.
Также язык представляет множество встроенных функций для использования специфичных для архитектуры \foreignlanguage{english}{Intel Processor Graphics} операций.

Данный язык позволяет максимально задействовать возможности аппаратуры, поэтому для дальнейшего исследования будет использоваться именно он.

\chapter{Постановка задачи}

В большинстве поколений архитектуры \foreignlanguage{english}{Intel Processor Graphics} существует поддержка чисел с двойной точностью и базовых операций над ними: сложение, умножение и так далее.
Однако инструкции подсчета математических функций экспонента и логарифм реализованы только для типов одинарной и половинной точности.
Однако такие функции являются необходимыми во многих научных вычислениях, где в отличие от графических приложений требуется именно работа с числами двойной точности.
Для языков OpenCL и DPC++ данные операции реализуются через функции математической библиотеки, в стандартной библиотеке языка CM таких функций нет.

В связи с этим в рамках данной работы была поставлена следующая цель --- разработать функции экспонента и логарифм для чисел двойной точности в математической библиотеке языка CM.

Для достижения цели были поставлены следующие задачи:

\begin{itemize}
    \item Изучить существующие подходы и теорию построения математических аппроксимаций;
    \item Изучить существующие реализации функций подсчета экспоненты и логарифма в открытых
    математических библиотеках;
    \item Выбрать алгоритм и реализовать функцию подсчета экспоненты;
    \item Выбрать алгоритм и реализовать функцию подсчета логарифма;
    \item Замерить точность реализованных функций;
    \item Замерить производительность реализованных функций и сравнить с аналогичными решениями
    для рассматриваемой архитектуры.
\end{itemize}

